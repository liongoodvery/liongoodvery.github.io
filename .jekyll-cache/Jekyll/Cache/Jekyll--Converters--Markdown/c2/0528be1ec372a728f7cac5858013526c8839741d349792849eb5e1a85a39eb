I"0<h2 id="图片和颜色">图片和颜色</h2>

<h3 id="tint属性">tint属性</h3>

<ul>
  <li>
    <p>tint属性一个颜色值，可以对图片做颜色渲染，我们可以给view的背景设置tint色值，给ImageView的图片设置tint色值，也可以给任意Drawable或者NinePatchDrawable设置tint色值。</p>
  </li>
  <li>
    <p>在应用的主题中也可以通过设置 <code class="highlighter-rouge">android:tint</code> 来给主题设置统一的颜色渲染。</p>
  </li>
  <li>
    <p>tint的渲染模式有总共有16种，xml文件中可以使用6种，代码中我们可以设置16种，渲染模式决定了渲染颜色和原图颜色的取舍和合成规则：</p>
  </li>
</ul>

<ol>
  <li><code class="highlighter-rouge">PorterDuff.Mode.CLEAR</code> 所绘制不会提交到画布上。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.SRC</code> 显示上层绘制图片</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.DST</code> 显示下层绘制图片</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.SRC_OVER</code> 正常绘制显示，上下层绘制叠盖。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.DST_OVER</code> 上下层都显示。下层居上显示。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.SRC_IN</code> 取两层绘制交集。显示上层。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.DST_IN</code> 取两层绘制交集。显示下层。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.SRC_OUT</code> 取上层绘制非交集部分。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.DST_OUT</code> 取下层绘制非交集部分。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.SRC_ATOP</code> 取下层非交集部分与上层交集部分</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.DST_ATOP</code> 取上层非交集部分与下层交集部分</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.XOR</code> 取两层绘制非交集。两层绘制非交集。</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.DARKEN</code> 上下层都显示。变暗</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.LIGHTEN</code> 上下层都显示。变亮</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.MULTIPLY</code> 取两层绘制交集</li>
  <li><code class="highlighter-rouge">PorterDuff.Mode.SCREEN</code> 上下层都显示。</li>
</ol>

<p>通过tint色处理的图片会原图显示出不一样的颜色，我们可以通过这种方式利用一张图片做出图片选择器的效果，让控件在按压状态下显示另外一种颜色:</p>

<h3 id="通过给图片设置tint色生成另外一种图片">通过给图片设置tint色生成另外一种图片</h3>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml">   <span class="nt">&lt;bitmap</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
            <span class="na">android:src=</span><span class="s">"@drawable/ring"</span>
            <span class="na">android:tintMode=</span><span class="s">"multiply"</span>
            <span class="na">android:tint=</span><span class="s">"#5677fc"</span> <span class="nt">&gt;</span>
    <span class="c">&lt;!--利用新的图片生成图片选择器--&gt;</span>
   <span class="nt">&lt;selector</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span><span class="nt">&gt;</span>
           <span class="nt">&lt;item</span> <span class="na">android:drawable=</span><span class="s">"@drawable/tint_bitmap"</span> <span class="na">android:state_pressed=</span><span class="s">"true"</span><span class="nt">&gt;</span>
           <span class="nt">&lt;item</span> <span class="na">android:drawable=</span><span class="s">"@drawable/ring"</span> <span class="nt">&gt;</span>
   <span class="nt">&lt;/selector&gt;</span>
 </code></pre></figure>

<h3 id="palette调色版">Palette调色版</h3>

<ul>
  <li>Palette调色板，可以很方便的让我们从图片中提取颜色。并且可以指定提取某种类型的颜色。</li>
</ul>

<ol>
  <li><code class="highlighter-rouge">Vibrant</code> 鲜艳的</li>
  <li><code class="highlighter-rouge">Vibrant</code> dark鲜艳的暗色</li>
  <li><code class="highlighter-rouge">Vibrant</code> light鲜艳的亮色</li>
  <li><code class="highlighter-rouge">Muted</code> 柔和的</li>
  <li><code class="highlighter-rouge">Muted</code> dark柔和的暗色</li>
  <li><code class="highlighter-rouge">Muted</code> light柔和的亮色</li>
</ol>

<ul>
  <li>对图片取色是一个比较消耗性能的操作，其内部会对图片的像素值进来遍历以分析对比，所以我们要在异步线程中去完成。</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="c1">//如果操作本来就属于后台线程，可以使用：
</span>
    <span class="nc">Palette</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Palette</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nc">Bitmap</span> <span class="n">bitmap</span><span class="o">);</span>
    <span class="c1">//如果在主线程中，我们可以使用异步的方式：
</span>
    <span class="nc">Palette</span><span class="o">.</span><span class="na">generateAsync</span><span class="o">(</span><span class="n">bitmap</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Palette</span><span class="o">.</span><span class="na">PaletteAsyncListener</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onGenerated</span><span class="o">(</span><span class="nc">Palette</span> <span class="n">palette</span><span class="o">)</span> <span class="o">{</span><span class="err"> </span> <span class="o">}</span>
    <span class="o">});</span>
   </code></pre></figure>

<ul>
  <li>当操作完成后或者异步回调后，我们就可以使用以下方式来获取对应的色值了，并且可以在没有获取到的情况下之指定默认值：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java">    <span class="n">p</span><span class="o">.</span><span class="na">getVibrantColor</span><span class="o">(</span><span class="kt">int</span> <span class="n">defaultColor</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">getDarkVibrantColor</span><span class="o">(</span><span class="kt">int</span> <span class="n">defaultColor</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">getLightVibrantColor</span><span class="o">(</span><span class="kt">int</span> <span class="n">defaultColor</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">getMutedColor</span><span class="o">(</span><span class="kt">int</span> <span class="n">defaultColor</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">getDarkMutedColor</span><span class="o">(</span><span class="kt">int</span> <span class="n">defaultColor</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">getLightMutedColor</span><span class="o">(</span><span class="kt">int</span> <span class="n">defaultColor</span><span class="o">);</span>
	</code></pre></figure>

<ul>
  <li>
    <p>在使用palette之前，bitmap提供获取指定位置的像素值： <code class="highlighter-rouge">bitmap.getPixel(x,y)</code></p>
  </li>
  <li>
    <p>是该方式只能获取某一点的像素值，palette是对整个bitmap的所有像素值进行分析，并选出几个像素占比比较多的像素值，这样选择出来的色值更符合图片的整体色值。</p>
  </li>
</ul>

<h2 id="vector矢量图">vector矢量图</h2>

<ul>
  <li>
    <p>矢量图也称为面向对象的图像或绘图图像，是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示图像。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。</p>
  </li>
  <li>
    <p>Android L开始支持矢量图，我们可以用它来处理一些图形简单的icon，方便我们的适配。</p>
  </li>
  <li>
    <p>Android L中对矢量图的支持是通过xml文件构建，通过矢量图的path描述来生成一个矢量图，对应的java对象为VectorDrawable。</p>
  </li>
  <li>
    <p>下面是官方文档提供的一个矢量图，利用改文件，我们可以创建一个随意放大缩小都不会失真的心形</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml">	<span class="nt">&lt;vector</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
            <span class="na">android:height=</span><span class="s">"300dp"</span>
            <span class="na">android:width=</span><span class="s">"300dp"</span>
            <span class="na">android:viewportHeight=</span><span class="s">"40"</span>
            <span class="na">android:viewportWidth=</span><span class="s">"40"</span><span class="nt">&gt;</span>
           <span class="nt">&lt;path</span> <span class="na">android:fillColor=</span><span class="s">"#ff00ff"</span>
                    <span class="na">android:pathData=</span><span class="s">"M20.5,9.5
                            c-1.955,0,-3.83,1.268,-4.5,3
                            c-0.67,-1.732,-2.547,-3,-4.5,-3
                            C8.957,9.5,7,11.432,7,14
                            c0,3.53,3.793,6.257,9,11.5
                            c5.207,-5.242,9,-7.97,9,-11.5
                            C25,11.432,23.043,9.5,20.5,9.5z"</span><span class="nt">/&gt;</span>
   <span class="nt">&lt;/vector&gt;</span>
	</code></pre></figure>

<ul>
  <li>矢量图的pathData数据就是用来描述矢量图的数学公式，其含义如下表：</li>
</ul>

<table>
<thead>
<tr>
<th>命令类型 </th>
<th> 使用描述 </th>
<th> 代表含义 </th>
<th> 举例说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>移动指令  </td>
<td> M x,y </td>
<td> M移动绝对位置 </td>
<td> M 100,240</td>
</tr>
<tr>
<td>移动指令 </td>
<td> m x,y </td>
<td> m移动相对于上一个点 </td>
<td> m 100,240</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> L 或 l </td>
<td> 从当前点绘制直线到指定点 </td>
<td> L 100,100</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> H 或 h </td>
<td> 水平直线 </td>
<td> h 100</td>
</tr>
<tr>
<td>绘制指令  </td>
<td> V 或 v </td>
<td> 垂直直线  </td>
<td> v 100</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> C 或 c </td>
<td> 三次方程式贝塞尔曲线 </td>
<td> C 100,200 200,400 300,200</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> Q 或 q </td>
<td> 二次方程式贝塞尔曲线 </td>
<td> Q 100,200 300,200</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> S 或 s </td>
<td> 平滑三次方程式贝塞尔曲线 </td>
<td> S 100,200 200,400 300,200</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> T 或 t </td>
<td> 平滑二次方程式贝塞尔曲线 </td>
<td> T 100,200 300,200</td>
</tr>
<tr>
<td>绘制指令 </td>
<td> A 或 a </td>
<td> 椭圆 </td>
<td> A 5,5 0 0 1 10,10</td>
</tr>
<tr>
<td>关闭指令 </td>
<td> Z 或 z </td>
<td> 将图形的首、尾点用直线连接 </td>
<td> Z</td>
</tr>
<tr>
<td>填充规则 </td>
<td> F0 </td>
<td> EvenOdd 填充规则</td>
<td></td>
</tr>
<tr>
<td>填充规则 </td>
<td> F1 </td>
<td> Nonzero 填充规则</td>
<td></td>
</tr>
</tbody>
</table>

<ul>
  <li>
    <p>通过path命令来进行简单的图形还是可行的，但是复杂的图形我们就需要借助工具来生成了，比如使用 Expression Design，就可以直接粘贴来自其它软件的矢量图形，然后选择导出，导出时做如后选择：文件-&gt;导出-&gt;导出属性-&gt;格式-&gt;XAML Silverlight 画布，即可得到XAML格式的矢量图形，也就是Path。</p>
  </li>
  <li>
    <p>更多矢量图学习可参考：<a href="http://www.w3.org/TR/SVG11/paths.html#PathData">http://www.w3.org/TR/SVG11/paths.html#PathData</a>
我们可以访问http://editor.method.ac在线制作矢量图并导出path</p>
  </li>
</ul>
:ET