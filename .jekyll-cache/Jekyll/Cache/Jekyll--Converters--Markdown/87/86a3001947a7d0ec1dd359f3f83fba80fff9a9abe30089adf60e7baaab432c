I"‡[<h2 id="process-descriptor">Process Descriptor</h2>

<ul>
  <li>A simplified task_struct</li>
  <li>include/linux/sched.h</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="c1">//////////////////////////Process AttributeRelated Fields//////////////////////////////////////</span>
    <span class="c1">//The state of the process. Values are TASK_RUNNING, TASK_INTERRUPTIBLE,</span>
    <span class="c1">// TASK_UNINTERRUPTIBLE, TASK_ZOMBIE, TASK_STOPPED and TASK_DEAD.</span>
    <span class="k">volatile</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
    <span class="c1">//Flags define special attributes that belong to the task. Values are</span>
    <span class="c1">//PF_STARTING, PF_EXITING, PF_DEAD and PF_FORKNOEXEC.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//ptrace is set when the ptrace() system call is called on the process for performance measurements.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptrace</span><span class="p">;</span>
    <span class="c1">//Linux supports a number of executable formats</span>
    <span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span><span class="n">binfmt</span><span class="p">;</span>
    <span class="c1">//the task's exit value and exit signal.</span>
    <span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">exit_signal</span><span class="p">;</span>
    <span class="c1">//pdeath_signal is a signal sent upon the parent's death.</span>
    <span class="kt">int</span> <span class="n">pdeath_signal</span><span class="p">;</span>
    <span class="c1">//Process Identifer</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="c1">//command line</span>
    <span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="c1">/////////////////////////Scheduling Related Fields///////////////////////////////////////</span>

    <span class="c1">//static_prio is equivalent to the nice value. The default value of static_prio is MAX_PRIO-20.</span>
    <span class="c1">//prio depends on the processes' scheduling history and the specified nice value</span>
    <span class="c1">//he prio field holds +/- 5 of the value of static_prio</span>
    <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="n">static_prio</span><span class="p">;</span>

    <span class="c1">//The run_list field points to the runqueue. A runqueue holds a list of all the processes to run.</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">run_list</span><span class="p">;</span>

    <span class="c1">//The array field points to the priority array of a runqueue</span>
    <span class="n">prio_array_t</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>

    <span class="c1">//The sleep_avg field is used to calculate the effective priority of the task,</span>
    <span class="c1">//which is the average amount of clock ticks the task has spent sleeping.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sleep_avg</span><span class="p">;</span>

    <span class="c1">//The timestamp field is used to calculate the sleep_avg for when a task sleeps or yields.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>

    <span class="c1">//The interactive_credit field is used along with the sleep_avg and activated fields to calculate sleep_avg.</span>
    <span class="kt">long</span> <span class="n">interactive_credit</span><span class="p">;</span>

    <span class="c1">//The policy determines the type of process (for example, time sharing or real time).</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">policy</span><span class="p">;</span>

    <span class="c1">//The activated field keeps track of the incrementing and decrementing of sleep averages.</span>
    <span class="kt">int</span> <span class="n">activated</span><span class="p">;</span>

    <span class="c1">//The cpus_allowed field specifies which CPUs might handle a task</span>
    <span class="n">cpumask_t</span> <span class="n">cpus_allowed</span><span class="p">;</span>

    <span class="c1">//The time_slice field defines the maximum amount of time the task is allowed to run.</span>
    <span class="c1">//The first_time_slice field is repeatedly set to 0 and keeps track of the scheduling time.</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_slice</span><span class="p">,</span> <span class="n">first_time_slice</span><span class="p">;</span>

    <span class="c1">//rt_priority is a static value that can only be updated through schedule().</span>
    <span class="c1">// This value is necessary to support real-time tasks.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rt_priority</span><span class="p">;</span>

    <span class="c1">//real_parent points to the current process' parent's description.</span>
    <span class="c1">// It will point to the process descriptor of init()</span>
    <span class="c1">// if the original parent of our current process has been destroyed.</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">real_parent</span><span class="p">;</span>

    <span class="c1">//parent is a pointer to the descriptor of the parent process.</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

    <span class="c1">//children is the struct that points to the list of our current process' children.</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>

    <span class="c1">//sibling is the struct that points to the list of the current process' siblings.</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">sibling</span><span class="p">;</span>

    <span class="c1">//A process can be a member of a group of processes,</span>
    <span class="c1">//and each group has one process defined as the group leader.</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">;</span>

    <span class="c1">////////////////////////Process CredentialsRelated Fields////////////////////////////////////////</span>

    <span class="c1">//The uid field holds the user ID number of the user who created the process.</span>
    <span class="c1">//The gid field holds the group ID of the group who owns the process.</span>
    <span class="c1">//The euid effective user ID</span>
    <span class="c1">//The egid effective group ID</span>
    <span class="c1">//suid (saved user ID) and sgid (saved group ID) are used in the setuid() system calls.</span>
    <span class="c1">//The fsuid and fsgid values are checked specifically for filesystem checks.</span>
    <span class="c1">// They generally hold the same values as uid and gid except for when a setuid() system call is made.</span>
    <span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="n">euid</span><span class="p">,</span> <span class="n">suid</span><span class="p">,</span> <span class="n">fsuid</span><span class="p">;</span>
    <span class="n">gid_t</span> <span class="n">gid</span><span class="p">,</span> <span class="n">egid</span><span class="p">,</span> <span class="n">sgid</span><span class="p">,</span> <span class="n">fsgid</span><span class="p">;</span>


    <span class="c1">//In Linux, a user may be part of more than one group.</span>
    <span class="c1">//These groups may have varying permissions with respect to system and data accesses.</span>
    <span class="c1">// For this reason, the processes need to inherit this credential.</span>
    <span class="k">struct</span> <span class="n">group_info</span> <span class="o">*</span><span class="n">group_info</span><span class="p">;</span>

    <span class="c1">/////////////////////////////Process CapabilitiesRelated Fields/////////////////////////////////////</span>

    <span class="c1">//cap_effective. The capabilities that can be currently used by the process.</span>
    <span class="c1">//cap_inheritable. The capabilities that are passed through a call to execve.</span>
    <span class="c1">//cap_permitted. The capabilities that can be made either effective or inheritable.</span>
    <span class="n">kernel_cap_t</span> <span class="n">cap_effective</span><span class="p">,</span> <span class="n">cap_inheritable</span><span class="p">,</span> <span class="n">cap_permitted</span><span class="p">;</span>

    <span class="c1">//////////////////////////////task_struct Resource Limits////////////////////////////////////</span>
    <span class="k">struct</span> <span class="n">rlimit</span> <span class="n">rlim</span><span class="p">[</span><span class="n">RLIM_NLIMITS</span><span class="p">];</span>

    <span class="c1">////////////////////////////Filesystem- and Address SpaceRelated Fields//////////////////////////////////////</span>
    <span class="c1">//The fs field holds a pointer to filesystem information.</span>
    <span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span><span class="p">;</span>
    <span class="c1">//The files field holds a pointer to the file descriptor table for the task.</span>
    <span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">;</span>

    <span class="c1">//mm points to address-space and memory-managementrelated information.</span>
    <span class="c1">//active_mm is a pointer to the most recently accessed address space. </span>
    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>

    <span class="c1">//////////////////////////////////////////////////////////////////</span>
    <span class="n">pid_t</span> <span class="n">tgid</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">usage</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lock_depth</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">thread_info</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptrace_children</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptrace_list</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pid_link</span> <span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_MAX</span><span class="p">];</span>
    <span class="n">wait_queue_head_t</span> <span class="n">wait_chldexit</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">vfork_done</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">set_child_tid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">clear_child_tid</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">it_real_value</span><span class="p">,</span> <span class="n">it_prof_value</span><span class="p">,</span> <span class="n">it_virt_value</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">it_real_incr</span><span class="p">,</span> <span class="n">it_prof_incr</span><span class="p">,</span> <span class="n">it_virt_incr</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">real_timer</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">utime</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">cutime</span><span class="p">,</span> <span class="n">cstime</span><span class="p">;</span>
    <span class="c1">//Different kinds of context switches exist.</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nvcsw</span><span class="p">,</span> <span class="n">nivcsw</span><span class="p">,</span> <span class="n">cnvcsw</span><span class="p">,</span> <span class="n">cnivcsw</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">start_time</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">keep_capabilities</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">used_math</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">link_count</span><span class="p">,</span> <span class="n">total_link_count</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptrace_message</span><span class="p">;</span>
    <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">last_siginfo</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div></div>

<p><img src="../assets/img/ProcessAttributeRelatedFields.jpg" alt="Process Attribute RelatedFields" />
<img src="../assets/img/SchedulingRelatedFields.jpg" alt="Scheduling Related Fields" />
<img src="../assets/img/ProcessRelationsRelatedFields.jpg" alt="ProcessRelations Related Fields" />
<img src="../assets/img/ProcessCredentialsRelatedFields.jpg" alt="Process CredentialsRelated Fields" />
<img src="../assets/img/ProcessCapabilitiesRelatedFields.jpg" alt="Process CapabilitiesRelated Fields" />
<img src="../assets/img/TaskStructResourceLimits.jpg" alt="task_struct Resource Limits" />
<img src="../assets/img/TaskStructResourceLimits.jpg" alt="Filesystem- and Address SpaceRelated Fields" /></p>

<h2 id="process-creation-fork-vfork-and-clone-system-calls">Process Creation: <code class="highlighter-rouge">fork()</code>, <code class="highlighter-rouge">vfork()</code>, and <code class="highlighter-rouge">clone()</code> System Calls</h2>
<p><img src="../assets/img/ProcessCreationSystemCalls.jpg" alt="Process Creation System Calls" /></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 *  Ok, this is the main fork-routine.
 *
 * It copies the process, and if successful kick-starts
 * it and waits for it to finish using the VM if required.
 */</span>
<span class="kt">long</span> <span class="nf">do_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_start</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">parent_tidptr</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tidptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">trace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">alloc_pidmap</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">trace</span> <span class="o">=</span> <span class="n">fork_traceflag</span> <span class="p">(</span><span class="n">clone_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="p">)</span>
			<span class="n">clone_flags</span> <span class="o">|=</span> <span class="n">CLONE_PTRACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">copy_process</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">stack_start</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span> <span class="n">parent_tidptr</span><span class="p">,</span> <span class="n">child_tidptr</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="cm">/*
	 * Do this prior waking up the new thread - the thread pointer
	 * might get invalid after that point, if the thread exits quickly.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">completion</span> <span class="n">vfork</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VFORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">vfork_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vfork</span><span class="p">;</span>
			<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfork</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_PTRACED</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_STOPPED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*
			 * We'll start up with an immediate SIGSTOP.
			 */</span>
			<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGSTOP</span><span class="p">);</span>
			<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TIF_SIGPENDING</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_STOPPED</span><span class="p">))</span>
			<span class="n">wake_up_new_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">clone_flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_STOPPED</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">trace</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace_message</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
			<span class="n">ptrace_notify</span> <span class="p">((</span><span class="n">trace</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">SIGTRAP</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VFORK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfork</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_TRACE_VFORK_DONE</span><span class="p">))</span>
				<span class="n">ptrace_notify</span> <span class="p">((</span><span class="n">PTRACE_EVENT_VFORK_DONE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">SIGTRAP</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">free_pidmap</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
:ET