I"„n<h2 id="nonblocking-io">Nonblocking I/O</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;apue.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">500000</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">ntowrite</span><span class="p">;</span>
    <span class="n">ntowrite</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"read %d bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntowrite</span><span class="p">);</span>
    <span class="n">set_fl</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nwrite</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ntowrite</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">nwrite</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ntowrite</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"nwrite = %d, errno = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nwrite</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nwrite</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ptr</span> <span class="o">+=</span> <span class="n">nwrite</span><span class="p">;</span>
            <span class="n">ntowrite</span> <span class="o">-=</span> <span class="n">nwrite</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">clr_fl</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span><span class="n">O_NONBLOCK</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="record-locking">Record Locking</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* struct flock *flockptr */</span> <span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">flock</span> <span class="p">{</span>
     <span class="kt">short</span> <span class="n">l_type</span><span class="p">;</span>   <span class="cm">/* F_RDLCK, F_WRLCK, or F_UNLCK */</span>
     <span class="kt">off_t</span> <span class="n">l_start</span><span class="p">;</span>  <span class="cm">/* offset in bytes, relative to l_whence */</span>
     <span class="kt">short</span> <span class="n">l_whence</span><span class="p">;</span> <span class="cm">/* SEEK_SET, SEEK_CUR, or SEEK_END */</span>
     <span class="kt">off_t</span> <span class="n">l_len</span><span class="p">;</span>    <span class="cm">/* length, in bytes; 0 means lock to EOF */</span>
     <span class="n">pid_t</span> <span class="n">l_pid</span><span class="p">;</span>    <span class="cm">/* returned with F_GETLK */</span>
   <span class="p">};</span>
</code></pre></div></div>

<h3 id="requesting-and-releasing-a-lock">Requesting and Releasing a Lock</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define read_lock(fd, offset, whence, len) \
            lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
            lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
            lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
            lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
            lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "apue.h"
#include &lt;fcntl.h&gt;
</span>
<span class="kt">int</span>
<span class="nf">lock_reg</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>

    <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>     <span class="cm">/* F_RDLCK, F_WRLCK, F_UNLCK */</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>  <span class="cm">/* byte offset, relative to l_whence */</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">whence</span><span class="p">;</span> <span class="cm">/* SEEK_SET, SEEK_CUR, SEEK_END */</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>       <span class="cm">/* #bytes (0 means to EOF) */</span>

    <span class="k">return</span><span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="testing-for-a-lock">Testing for a Lock</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define is_read_lockable(fd, offset, whence, len) \
          (lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)
#define is_write_lockable(fd, offset, whence, len) \
          (lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "apue.h"
#include &lt;fcntl.h&gt;
</span>
<span class="n">pid_t</span>
<span class="nf">lock_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>     <span class="cm">/* F_RDLCK or F_WRLCK */</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>  <span class="cm">/* byte offset, relative to l_whence */</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">whence</span><span class="p">;</span> <span class="cm">/* SEEK_SET, SEEK_CUR, SEEK_END */</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>       <span class="cm">/* #bytes (0 means to EOF) */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"fcntl error"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="cm">/* false, region isn't locked by another proc */</span>
    <span class="k">return</span><span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">l_pid</span><span class="p">);</span> <span class="cm">/* true, return pid of lock owner */</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="deadlock">DeadLock</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include &lt;apue.h&gt;
#include &lt;fcntl.h&gt;
</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lockabyte</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">writew_lock</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"%s: writew_lock error"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s: got the lock, byte %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">creat</span><span class="p">(</span><span class="s">"file.tmp"</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"create file error"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">"ab"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"write error"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">TELL_WAIT</span><span class="p">();</span>

    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"fork error"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lockabyte</span><span class="p">(</span><span class="s">"child"</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">TELL_PARENT</span><span class="p">(</span><span class="n">getppid</span><span class="p">());</span>
        <span class="n">WAIT_PARENT</span><span class="p">();</span>
        <span class="n">lockabyte</span><span class="p">(</span><span class="s">"child"</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">lockabyte</span><span class="p">(</span><span class="s">"parent"</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">TELL_CHILD</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
        <span class="n">WAIT_CHILD</span><span class="p">();</span>
        <span class="n">lockabyte</span><span class="p">(</span><span class="s">"parent"</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "apue.h"
</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">sig_atomic_t</span> <span class="n">sigflag</span><span class="p">;</span> <span class="cm">/* set nonzero by sig handler */</span>
<span class="k">static</span> <span class="n">sigset_t</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">,</span> <span class="n">zeromask</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>    <span class="cm">/* one signal handler for SIGUSR1 and SIGUSR2 */</span>
<span class="p">{</span>
    <span class="n">sigflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TELL_WAIT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"signal(SIGUSR1) error"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR2</span><span class="p">,</span> <span class="n">sig_usr</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIG_ERR</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"signal(SIGUSR2) error"</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR2</span><span class="p">);</span>

    <span class="cm">/* Block SIGUSR1 and SIGUSR2, and save current signal mask */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"SIG_BLOCK error"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TELL_PARENT</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGUSR2</span><span class="p">);</span>        <span class="cm">/* tell parent we're done */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WAIT_PARENT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sigflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>    <span class="cm">/* and wait for parent */</span>
    <span class="n">sigflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Reset signal mask to original value */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"SIG_SETMASK error"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TELL_CHILD</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>            <span class="cm">/* tell child we're done */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WAIT_CHILD</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sigflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>    <span class="cm">/* and wait for child */</span>
    <span class="n">sigflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Reset signal mask to original value */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">"SIG_SETMASK error"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Result</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parent: got the lock, byte 1
child: got the lock, byte 0
child: writew_lock error: Resource deadlock avoided
parent: got the lock, byte 0
</code></pre></div></div>

<h3 id="implied-inheritance-and-release-of-locks">Implied Inheritance and Release of Locks</h3>
<blockquote>
  <p>Locks are associated with a process and a file. This has two implications. The first is obvious: when a process terminates, all its locks are released. The second is far from obvious: whenever a descriptor is closed, any locks on the file referenced by that descriptor for that process are released.</p>
</blockquote>

<blockquote>
  <p>Locks are never inherited by the child across a fork.
Locks are inherited by a new program across an exec. Note, however, that if the close-on-exec flag is set for a file descriptor, all locks for the underlying file are released when the descriptor is closed as part of an exec.</p>
</blockquote>

<h3 id="advisory-versus-mandatory-locking">Advisory versus Mandatory Locking</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;stdio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_WRONLY</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Unable to open the file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">static</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>

        <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">lock</span><span class="p">.</span><span class="n">l_pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Return value of fcntl:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">scanf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># mount -oremount,mand /
# touch advisory.txt
# touch mandatory.txt
# chmod g+s,g-x mandatory.txt
# ./file_lock advisory.txt
# ls &gt;&gt;advisory.txt
# ./file_lock mandatory.txt
# ls &gt;&gt;mandatory.txt
</code></pre></div></div>
:ET